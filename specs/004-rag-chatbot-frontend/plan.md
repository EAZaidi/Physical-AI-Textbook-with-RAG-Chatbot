# Implementation Plan: RAG Chatbot Frontend Integration

**Branch**: `004-rag-chatbot-frontend` | **Date**: 2025-12-17 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/004-rag-chatbot-frontend/spec.md`

**Note**: This plan was generated by the `/sp.plan` command based on comprehensive research, data modeling, API contracts, and quickstart documentation.

## Summary

**Primary Requirement**: Integrate an interactive RAG chatbot into the Physical AI textbook frontend (Docusaurus) that connects to the FastAPI backend (003-rag-agent-api) to enable readers to ask questions about textbook content and receive grounded answers with citations directly in the browser.

**Technical Approach**:
- **Framework Integration**: Build React components within existing Docusaurus site (no iframe/extension)
- **State Management**: React Context API with sessionStorage for persistence across page navigations
- **API Client**: Native fetch API with custom hooks for synchronous and streaming (SSE) requests
- **Streaming**: EventSource API with @microsoft/fetch-event-source polyfill for POST SSE support
- **Markdown Rendering**: react-markdown with remark-gfm for formatted responses
- **Text Selection**: window.getSelection() API with Cmd/Ctrl+K keyboard shortcut
- **Configuration**: Environment variables via Docusaurus customFields
- **Accessibility**: ARIA labels, keyboard navigation (Tab/Enter/Esc), WCAG 2.1 AA compliance
- **Mobile**: Responsive design (full screen <768px, sidebar >768px)

**MVP Scope** (Priority P1): Basic chatbot interaction - ask questions, receive grounded answers with citations (User Story 1).

---

## Technical Context

**Language/Version**: TypeScript 5.x, React 18.x (via Docusaurus 3.x), Node.js 18+
**Primary Dependencies**:
- Docusaurus 3.x (static site generator, React framework)
- react-markdown 9.x (markdown rendering)
- @microsoft/fetch-event-source 2.x (POST SSE streaming)
- remark-gfm 4.x (GitHub Flavored Markdown support)

**Storage**: sessionStorage (browser) for conversation history and panel state. No server-side storage in frontend.

**Testing**:
- Unit tests: Jest + React Testing Library (test components, hooks, API client)
- Integration tests: Playwright/Cypress (test full user flows with mock backend)
- E2E tests: Playwright with real backend (test complete Q&A cycle)

**Target Platform**: Modern browsers (Chrome, Firefox, Safari, Edge - last 2 versions). No IE11 support. Mobile browsers (iOS Safari 14+, Android Chrome 90+).

**Project Type**: Web frontend integration (React components injected into existing Docusaurus site)

**Performance Goals**:
- SC-001: p95 response latency < 5 seconds (end-to-end Q&A cycle)
- SC-002: Chat interface loads < 1 second
- SC-006: Streaming first token < 1 second
- Lighthouse performance score: > 90

**Constraints**:
- Backend API latency: 2-4 seconds (from 003-rag-agent-api)
- Text selection: max 5000 characters (SC-004)
- Message length: max 1000 characters (backend validation)
- Session persistence: browser-session-scoped only (no cross-device)
- No authentication: MVP uses open API or simple API key

**Scale/Scope**:
- 4 user stories (P1-P4): Basic Q&A, Text selection, Conversation history, Streaming
- 15 functional requirements (FR-001 to FR-015)
- 10 success criteria (SC-001 to SC-010)
- ~8-10 React components
- ~1500-2000 lines of TypeScript code
- Target: 10-100 concurrent users (MVP), backend handles scaling

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-checked after Phase 1 design.*

**Constitution File**: `.specify/memory/constitution.md`

### Principle 1: Feature Quality ✅ PASS
- All 4 user stories have independent test descriptions (from spec.md)
- All 10 success criteria are measurable (latency, load time, persistence rate)
- MVP (P1) delivers core value: ask questions, receive grounded answers
- Scope is bounded: 15 functional requirements, clear out-of-scope items

### Principle 2: Code Quality ✅ PASS
- TypeScript provides type safety (all entities in data-model.md)
- React Context API provides clear state boundaries
- API client abstracted into dedicated module (api.ts)
- Components follow single-responsibility principle
- Input validation at boundaries (message length, UUID format)

### Principle 3: Testing ✅ PASS
- Unit tests: All components, hooks, API client functions testable in isolation
- Integration tests: User flows testable with mock backend
- E2E tests: Complete Q&A cycle testable with real backend
- Acceptance scenarios defined for each user story (16 total)
- 8 edge cases identified and documented

### Principle 4: Performance ✅ PASS
- Streaming reduces perceived latency (SC-006: < 1s first token)
- sessionStorage provides fast persistence (no API calls)
- Lazy loading for chatbot (loads only when user interacts)
- React.memo for expensive components (message list)
- Minimal dependencies (react-markdown, fetch-event-source only)

### Principle 5: Security ✅ PASS
- No sensitive data in sessionStorage (only conversation history)
- API key stored in environment variables (not in code)
- Input sanitization handled by backend (frontend sends plain text)
- CORS enforced by backend (frontend origin allowlisted)
- HTTPS required for production (backend URL validation)

### Principle 6: Architecture ✅ PASS
- Clear separation: UI components, state management, API client
- React Context provides centralized state (no prop drilling)
- API client abstraction allows backend changes without UI changes
- Streaming fallback to synchronous (graceful degradation)
- No external state management library needed (Context API sufficient)

### Principle 7: Documentation ✅ PASS
- Comprehensive specification (spec.md) with user stories and requirements
- Data model documentation (data-model.md) with validation rules
- API contract documentation (contracts/backend-api.md)
- Quickstart guide (quickstart.md) with step-by-step setup
- All TypeScript interfaces documented with JSDoc comments

**Result**: All 7 constitution principles satisfied. No violations to track.

---

## Project Structure

### Documentation (this feature)

```text
specs/004-rag-chatbot-frontend/
├── spec.md                    # Feature specification (4 user stories, 15 requirements)
├── plan.md                    # This file (implementation plan)
├── research.md                # Technical decisions (10 decisions documented)
├── data-model.md              # TypeScript interfaces (ChatMessage, ChatSession, Source, etc.)
├── quickstart.md              # Developer setup guide (< 30 minutes)
├── contracts/                 # API integration documentation
│   └── backend-api.md         # Backend API contract (POST /chat/run, /chat/stream, GET /health)
├── checklists/                # Specification validation
│   └── requirements.md        # All 12 validation items passed
└── tasks.md                   # Task breakdown (to be created by /sp.tasks command)
```

### Source Code (repository root)

**Structure Decision**: This is a **frontend integration feature** for an existing Docusaurus site. The chatbot components will be added to the `docs/` directory (Docusaurus project root). The backend already exists at `backend/` (from feature 003-rag-agent-api).

```text
docs/                                  # Docusaurus project root
├── src/
│   ├── components/
│   │   └── RAGChatbot/               # New: Chatbot feature
│   │       ├── index.tsx             # Main export (ChatbotWrapper)
│   │       ├── ChatContext.tsx       # React Context (state management)
│   │       ├── ChatProvider.tsx      # Context Provider component
│   │       ├── ChatPanel.tsx         # Chat UI panel (messages, input, controls)
│   │       ├── ChatMessage.tsx       # Individual message component
│   │       ├── ChatInput.tsx         # Message input with textarea and submit
│   │       ├── ChatToggle.tsx        # Floating toggle button (bottom-right)
│   │       ├── SourceCitation.tsx    # Source display component
│   │       ├── ConfidenceBadge.tsx   # Confidence level indicator
│   │       ├── ErrorMessage.tsx      # Error display component
│   │       ├── LoadingIndicator.tsx  # Loading spinner/animation
│   │       ├── types.ts              # TypeScript interfaces (from data-model.md)
│   │       ├── api.ts                # API client (sendChatMessage, streamChatMessage)
│   │       ├── hooks.ts              # Custom hooks (useChatContext, useTextSelection)
│   │       ├── utils.ts              # Utility functions (session ID, validation)
│   │       └── styles.module.css     # Component styles (responsive, accessible)
│   │
│   ├── theme/
│   │   └── Root.tsx                  # Docusaurus theme wrapper (integrates chatbot globally)
│   │
│   └── pages/                        # Docusaurus pages (unchanged)
│
├── static/                            # Static assets
│   └── img/
│       └── chat-icon.svg             # New: Chatbot toggle icon
│
├── docusaurus.config.js              # Updated: Add customFields (ragBackendUrl, ragApiKey)
├── package.json                      # Updated: Add dependencies
├── tsconfig.json                     # TypeScript configuration
└── .env.local                        # New: Local environment variables (not committed)

backend/                               # Existing backend (003-rag-agent-api)
├── agent_api/
│   ├── routers/
│   │   └── chat.py                   # POST /chat/run, POST /chat/stream
│   └── main.py                       # FastAPI app with CORS
└── README.md                         # Backend documentation

.env                                   # Production environment variables (not committed)
.env.example                          # Example environment variables (committed)
```

**Key Directories**:
- `docs/src/components/RAGChatbot/`: All chatbot components and logic (12-15 files)
- `docs/src/theme/Root.tsx`: Global integration point (wraps entire Docusaurus site)
- `backend/`: Existing backend API (no changes needed, already complete)

**New Files** (created by this feature):
- 12-15 TypeScript files in `docs/src/components/RAGChatbot/`
- 1 TypeScript file: `docs/src/theme/Root.tsx`
- 1 SVG file: `docs/static/img/chat-icon.svg`
- 1 config file update: `docs/docusaurus.config.js`
- 2 environment files: `docs/.env.local`, `.env.example`

---

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. All 7 constitution principles passed. No complexity justification required.

---

## Component Architecture

### High-Level Component Hierarchy

```
Root.tsx (Docusaurus theme wrapper)
└── ChatProvider (Context provider with backend config)
    └── RAGChatbot (Main component)
        ├── ChatToggle (Floating button, bottom-right)
        │   └── onClick → toggle panel open/closed
        │
        └── ChatPanel (Conditional render when open)
            ├── Header
            │   ├── Title ("Ask AI about this textbook")
            │   ├── New Conversation button
            │   └── Close button (X)
            │
            ├── MessageList (Scrollable)
            │   └── ChatMessage[] (map over session.messages)
            │       ├── role === 'user'
            │       │   └── User message bubble (right-aligned)
            │       └── role === 'assistant'
            │           ├── Assistant message bubble (left-aligned)
            │           ├── ReactMarkdown (content rendering)
            │           ├── ConfidenceBadge (if confidence present)
            │           └── SourceCitation[] (if sources present)
            │
            ├── ErrorMessage (Conditional, if session.error)
            │
            └── ChatInput
                ├── SelectedContext (if present, dismissible)
                ├── Textarea (autosize, placeholder, max 1000 chars)
                ├── LoadingIndicator (if session.isLoading)
                └── Submit button (Enter or click)
```

### Component Responsibilities

**Root.tsx** (Docusaurus theme wrapper):
- Reads backend config from Docusaurus customFields
- Wraps site with ChatProvider (global state)
- Renders RAGChatbot component

**ChatProvider** (Context provider):
- Manages ChatSession state (messages, loading, error)
- Loads session from sessionStorage on mount
- Saves session to sessionStorage on every update
- Provides sendMessage, clearHistory, setSelectedContext methods
- Handles API calls (sync or stream based on config)

**RAGChatbot** (Main component):
- Renders ChatToggle (always visible)
- Conditionally renders ChatPanel (when open)
- Handles text selection keyboard shortcut (Cmd/Ctrl+K)

**ChatToggle** (Floating button):
- Fixed position (bottom-right, above footer)
- Shows unread indicator (if new messages while closed)
- Keyboard accessible (Tab, Enter)
- Mobile: Larger touch target (48x48px)

**ChatPanel** (Chat UI):
- Positioned: Fixed (desktop), Full-screen (mobile)
- Desktop: Right sidebar (400px width, full height)
- Mobile: Full viewport (100vw x 100vh)
- Auto-scroll to bottom on new messages
- Keyboard accessible (Esc to close, Tab navigation)

**ChatMessage** (Individual message):
- Displays role-specific styling (user vs assistant)
- Renders markdown for assistant messages (react-markdown)
- Shows timestamp (relative: "2 minutes ago")
- Displays confidence badge if present
- Renders source citations as expandable list

**ChatInput** (Message input):
- Textarea with auto-resize (1-5 lines)
- Character counter (show when >800 chars, warn at 1000)
- Submit on Enter (Shift+Enter for newline)
- Disabled when loading
- Shows selected context as dismissible chip

**SourceCitation** (Citation display):
- Shows chapter and section prominently
- Displays similarity score as percentage
- Clickable link to source content
- Expandable to show chunk excerpt
- Truncate long chunk_text (show first 150 chars)

**ConfidenceBadge** (Confidence indicator):
- High (≥0.8): Green badge, "High confidence"
- Medium (0.6-0.8): Yellow badge, "Medium confidence"
- Low (0.4-0.6): Orange badge, "Low confidence"
- Insufficient (<0.4): Red badge, "Insufficient confidence"
- Tooltip explains confidence meaning

**ErrorMessage** (Error display):
- User-friendly error text (from error mapping in api.ts)
- Retry button (if error is retryable)
- Dismiss button (clear error state)
- Accessible (role="alert", announced by screen readers)

**LoadingIndicator** (Loading state):
- Animated spinner (CSS animation, no GIF)
- Text: "Searching textbook..." (tool_call/retrieval phase)
- Text: "Generating answer..." (streaming phase)
- Accessible (aria-live="polite")

---

## State Management Strategy

### React Context API

**Why Context API** (vs Redux, Zustand, Jotai):
- Simple feature with local state (no global app state)
- Single source of truth: ChatSession
- No complex state updates (append messages, toggle loading)
- Built-in to React (no additional dependencies)

**Context Structure**:
```typescript
interface ChatContextType {
  session: ChatSession;              // Current session state
  sendMessage: (message: string) => Promise<void>;
  clearHistory: () => void;
  setSelectedContext: (text: string | null) => void;
  config: BackendConfig;             // Immutable backend config
}
```

**State Updates**:
1. **User submits message**:
   - Append user message to session.messages
   - Set session.isLoading = true
   - Call API (sync or stream)
   - Append assistant message when complete
   - Set session.isLoading = false
   - Save to sessionStorage

2. **User clears history**:
   - Generate new sessionId (crypto.randomUUID())
   - Reset session.messages = []
   - Clear session.error, session.selectedContext
   - Save to sessionStorage

3. **User selects text** (Cmd/Ctrl+K):
   - Capture selected text (window.getSelection())
   - Set session.selectedContext = text
   - Open chat panel
   - Focus input field

4. **Streaming response**:
   - Create assistant message with isStreaming: true
   - Append to session.messages
   - On each content delta: append to message.content
   - On done event: update message metadata (confidence, sources)
   - Set isStreaming: false
   - Save to sessionStorage

### Session Storage Schema

**Key**: `rag-chatbot-session`

**Value** (JSON):
```json
{
  "sessionId": "550e8400-e29b-41d4-a716-446655440000",
  "messages": [
    {
      "id": "msg-uuid-1",
      "role": "user",
      "content": "What is a ROS 2 node?",
      "timestamp": "2025-12-17T10:30:00.000Z"
    },
    {
      "id": "msg-uuid-2",
      "role": "assistant",
      "content": "A ROS 2 node is...",
      "timestamp": "2025-12-17T10:30:03.000Z",
      "confidence": 0.89,
      "confidenceLevel": "high",
      "sources": [...]
    }
  ],
  "createdAt": "2025-12-17T10:30:00.000Z",
  "lastUpdatedAt": "2025-12-17T10:30:03.000Z",
  "selectedContext": null,
  "isLoading": false,
  "error": null
}
```

**Persistence Strategy**:
- Save on every message update (useEffect dependency: session)
- Load on component mount (initial state)
- Clear on "New Conversation" button click
- Cleared automatically when browser session ends

---

## API Client Design

### Synchronous API Call (POST /chat/run)

**Function**: `sendChatMessage(request, config) => Promise<ChatResponse>`

**Flow**:
1. Construct request body: {message, session_id, context?, history?}
2. Call fetch() with POST method
3. Set timeout: AbortSignal.timeout(config.timeoutMs)
4. Include API key header if present
5. Parse JSON response
6. Handle errors: 400 (validation), 429 (rate limit), 503 (service unavailable)
7. Return ChatResponse

**Error Handling**:
- Network error (CORS, DNS, connection): Throw with type: 'network', retryable: true
- 400: Throw with type: 'validation', retryable: false
- 429: Throw with type: 'backend', retryable: true, include retry_after
- 503: Throw with type: 'backend', retryable: true
- Timeout: Throw with type: 'timeout', retryable: true

**Retry Logic**:
- Max retries: config.retryAttempts (default: 2)
- Exponential backoff: 2^attempt * 1000ms (1s, 2s, 4s)
- Only retry if error.retryable === true
- Respect retry_after header for 429 errors

### Streaming API Call (POST /chat/stream)

**Function**: `streamChatMessage(request, config, callbacks) => Promise<void>`

**Callbacks**:
- `onToken(token: string)`: Called for each content delta
- `onDone(response: ChatResponse)`: Called when stream completes
- `onError(error: Error)`: Called on stream error

**Flow**:
1. Call fetchEventSource() from @microsoft/fetch-event-source
2. POST to /chat/stream with request body
3. Handle events:
   - `tool_call`: Log for debugging (not shown to user)
   - `retrieval`: Log for debugging (not shown to user)
   - `content`: Call onToken(data.delta)
   - `done`: Call onDone(data)
   - `error`: Call onError(data.error)
4. On connection error: Log warning, fallback to sendChatMessage()

**Fallback Strategy**:
- If SSE connection fails (CORS, browser compatibility): Catch error in onerror
- Log warning to console: "Streaming failed, falling back to sync"
- Call sendChatMessage() instead (synchronous)
- Update UI: Display complete response after it arrives (no streaming)

### Request Validation

**Client-Side Validation** (before API call):
- Message: 1-1000 characters, non-empty, trimmed
- Session ID: Valid UUID v4 format (regex validation)
- Context: 0-5000 characters, trimmed
- History: Max 10 messages, each with role + content

**Validation Errors** (display to user):
- Empty message: "Please enter a question"
- Message too long: "Question is too long (max 1000 characters)"
- Context too long: "Selected text is too long (max 5000 characters)"

---

## Text Selection Implementation

### User Flow
1. User selects text on page (mouse drag or keyboard shift+arrows)
2. User presses Cmd+K (Mac) or Ctrl+K (Windows/Linux)
3. Chatbot panel opens (if closed)
4. Selected text appears as context chip above input
5. User types question referencing selection
6. Submit sends both message and context to backend

### Technical Implementation

**Event Listener**:
```typescript
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      const selection = window.getSelection();
      if (selection && selection.toString().length > 0) {
        const text = selection.toString().trim();
        if (text.length <= 5000) {
          setSelectedContext(text);
          openPanel();
          focusInput();
        } else {
          showError('Selected text is too long (max 5000 characters)');
        }
      }
    }
  };

  document.addEventListener('keydown', handleKeyDown);
  return () => document.removeEventListener('keydown', handleKeyDown);
}, []);
```

**Context Display**:
- Show selected text in a dismissible chip above input field
- Truncate display to 100 characters (show full text in tooltip)
- Clicking X clears selectedContext
- Context is included in API request as `context` field

**Accessibility**:
- Keyboard shortcut is documented in help text
- Context chip has role="status" (announced by screen readers)
- Dismiss button has aria-label="Clear selected context"

---

## Markdown Rendering

### Library Choice

**Selected**: react-markdown + remark-gfm

**Why**:
- Lightweight (~50KB minified)
- Renders GitHub Flavored Markdown (tables, strikethrough, task lists)
- Sanitizes HTML by default (no XSS risk)
- Customizable components (can style code blocks, links)
- SSR-compatible (Docusaurus requirement)

**Alternatives Rejected**:
- marked: No React integration, must use dangerouslySetInnerHTML
- markdown-it: Heavier, more features than needed

### Supported Markdown Features

**Basic Formatting**:
- **Bold** (`**text**`)
- *Italic* (`*text*`)
- `Code` (`` `code` ``)
- [Links](url) (`[text](url)`)

**Blocks**:
- Paragraphs (double newline)
- Headings (`# H1`, `## H2`, etc.)
- Code blocks (` ```lang ... ``` `)
- Blockquotes (`> text`)
- Lists (ordered `1.`, unordered `-`)
- Tables (GFM syntax)

**Out of Scope** (from spec.md):
- LaTeX math (`$...$`, `$$...$$`)
- Diagrams (Mermaid, PlantUML)
- Embeds (YouTube, Twitter)
- Custom components

### Code Block Styling

```typescript
<ReactMarkdown
  remarkPlugins={[remarkGfm]}
  components={{
    code({ node, inline, className, children, ...props }) {
      const match = /language-(\w+)/.exec(className || '');
      return !inline && match ? (
        <SyntaxHighlighter
          language={match[1]}
          style={vscDarkPlus}
          {...props}
        >
          {String(children).replace(/\n$/, '')}
        </SyntaxHighlighter>
      ) : (
        <code className={className} {...props}>
          {children}
        </code>
      );
    }
  }}
>
  {content}
</ReactMarkdown>
```

---

## Mobile Responsiveness

### Breakpoints

**Desktop** (>= 768px):
- Chat panel: Fixed right sidebar (400px width, full height)
- Chat toggle: Bottom-right (20px from bottom, 20px from right)
- Input: Single line, expands to 5 lines max

**Tablet** (768px - 1024px):
- Chat panel: Fixed right sidebar (350px width)
- Chat toggle: Bottom-right (same as desktop)

**Mobile** (< 768px):
- Chat panel: Full-screen overlay (100vw x 100vh)
- Chat toggle: Bottom-center (centered horizontally)
- Input: Multi-line (3 lines visible), larger font (16px to prevent zoom)

### Touch Interactions

**Chat Toggle**:
- Touch target: 48x48px minimum (WCAG guideline)
- Tap feedback: Scale down slightly, background color change

**Message List**:
- Touch scroll: Native browser scrolling (overflow-y: auto)
- Pull-to-refresh: Disabled (no need to refresh messages)

**Input**:
- Touch keyboard: Auto-focus on panel open (mobile)
- Submit button: Large touch target (44x44px)

**Sources**:
- Expandable: Tap to expand/collapse (no hover on mobile)
- Links: Large touch targets (full width of citation)

### Layout Adjustments

**Portrait** (default):
- Full-screen panel, input at bottom (fixed position)
- Messages scroll in remaining space

**Landscape**:
- Reduced panel height (leave space for keyboard)
- Input stays above keyboard (position: sticky)

---

## Accessibility Implementation

### Keyboard Navigation

**Global Shortcuts**:
- `Cmd/Ctrl+K`: Open chat panel and focus input
- `Esc`: Close chat panel

**Within Chat Panel**:
- `Tab`: Navigate through interactive elements (input, buttons, links)
- `Shift+Tab`: Navigate backwards
- `Enter`: Submit message (in input)
- `Shift+Enter`: Insert newline (in input)
- `Esc`: Close panel

**Focus Management**:
- When panel opens: Auto-focus input field
- When panel closes: Return focus to toggle button
- Tab order: Close button → New Conversation → Messages → Input → Submit

### Screen Reader Support

**ARIA Labels**:
```typescript
<div role="region" aria-label="AI chatbot">
  <button aria-label="Open chatbot" aria-expanded={isOpen}>
    <ChatIcon />
  </button>

  <div role="dialog" aria-labelledby="chat-title">
    <h2 id="chat-title">Ask AI about this textbook</h2>

    <div role="log" aria-live="polite" aria-relevant="additions">
      {messages.map(msg => (
        <div role="article" aria-label={`${msg.role} message`}>
          {msg.content}
        </div>
      ))}
    </div>

    <form aria-label="Send message">
      <textarea aria-label="Type your question" />
      <button type="submit" aria-label="Send message">Send</button>
    </form>
  </div>
</div>
```

**Live Regions**:
- Message list: `aria-live="polite"` (announce new messages)
- Error messages: `role="alert"` (immediately announced)
- Loading indicator: `aria-live="polite"` (announce state changes)

**Announcements**:
- New message: "Assistant: [first 50 characters of message]"
- Error: "[Error message], press retry to try again"
- Loading: "Searching textbook, please wait"

### Visual Accessibility

**Color Contrast** (WCAG 2.1 AA):
- Text on background: Minimum 4.5:1 ratio
- Interactive elements: Minimum 3:1 ratio
- Confidence badges: Use icons + text (not color alone)

**Focus Indicators**:
- Visible focus outline (2px solid, high contrast)
- Focus style: Blue outline (#0066CC), 2px solid
- Skip-to-input link at top of panel (for keyboard users)

**Text Sizing**:
- Base font size: 16px (prevents mobile zoom)
- Relative units: rem/em (respects user font preferences)
- No fixed heights (allow text reflow at 200% zoom)

---

## Error Handling Strategy

### Error Types and User Messages

**Network Errors** (CORS, DNS, connection refused):
- **User Message**: "Unable to connect to the chatbot service. Please check your connection."
- **Action**: Retry button (retry immediately)
- **Logging**: `console.error('[RAG] Network error:', error)`

**Validation Errors** (400):
- **User Message**: Extract from backend response (e.g., "Question is too long")
- **Action**: No retry (user must fix input)
- **Logging**: `console.warn('[RAG] Validation error:', error)`

**Rate Limit** (429):
- **User Message**: "Too many questions. Please wait [N] seconds before trying again."
- **Action**: Retry button (disabled until retry_after expires)
- **Logging**: `console.warn('[RAG] Rate limit hit, retry after:', retry_after)`

**Service Unavailable** (503):
- **User Message**: "The chatbot is temporarily unavailable. Please try again."
- **Action**: Retry button (retry after 5 seconds)
- **Logging**: `console.error('[RAG] Backend unavailable:', error)`

**Timeout** (>30s):
- **User Message**: "The response is taking longer than expected. Please try again."
- **Action**: Retry button (retry immediately)
- **Logging**: `console.error('[RAG] Request timeout after 30s')`

**Low Confidence** (should_answer: false):
- **User Message**: "I couldn't find relevant information to answer your question. Try rephrasing or asking about a different topic."
- **Action**: No retry (user should rephrase)
- **Logging**: `console.info('[RAG] Low confidence, refusal reason:', refusal_reason)`

### Error Display Component

```typescript
interface ErrorMessageProps {
  error: string;
  retryable: boolean;
  onRetry?: () => void;
  onDismiss: () => void;
}

function ErrorMessage({ error, retryable, onRetry, onDismiss }: ErrorMessageProps) {
  return (
    <div role="alert" className="error-message">
      <AlertIcon />
      <p>{error}</p>
      <div className="error-actions">
        {retryable && onRetry && (
          <button onClick={onRetry} aria-label="Retry request">
            Retry
          </button>
        )}
        <button onClick={onDismiss} aria-label="Dismiss error">
          Dismiss
        </button>
      </div>
    </div>
  );
}
```

### Logging Strategy

**Development** (process.env.NODE_ENV === 'development'):
- Log all API requests and responses
- Log state changes (message added, session cleared)
- Log errors with full stack traces

**Production** (process.env.NODE_ENV === 'production'):
- Log errors only (no request/response logging)
- Sanitize error messages (no sensitive data)
- Optional: Send errors to error tracking service (Sentry)

---

## Performance Optimization

### Lazy Loading

**Chatbot Component**:
```typescript
// Lazy load chatbot (only when user interacts)
const RAGChatbot = React.lazy(() => import('./components/RAGChatbot'));

function Root({ children }) {
  return (
    <>
      {children}
      <React.Suspense fallback={null}>
        <RAGChatbot />
      </React.Suspense>
    </>
  );
}
```

### React Optimization

**Memoization**:
```typescript
// Memoize expensive components
const ChatMessage = React.memo(({ message }) => {
  // Render message
}, (prev, next) => prev.message.id === next.message.id);

// Memoize callbacks
const sendMessage = useCallback(async (message: string) => {
  // API call
}, [sessionId, config]);
```

**Virtual Scrolling** (if message list grows >100 messages):
- Use react-window for virtualized list
- Render only visible messages (10-20 at a time)
- Reduces DOM nodes, improves scroll performance

### Bundle Size

**Dependencies**:
- react-markdown: ~50KB
- @microsoft/fetch-event-source: ~10KB
- remark-gfm: ~30KB
- Total: ~90KB (acceptable for feature)

**Code Splitting**:
- Chatbot loaded lazily (not in initial bundle)
- Markdown renderer loaded lazily (only when assistant responds)

### API Performance

**Request Optimization**:
- Send only last 5 messages in history (not entire conversation)
- Compress long context (truncate to 5000 chars)
- Use streaming for long responses (perceived performance)

**Caching** (future enhancement, not MVP):
- Cache responses in sessionStorage (by message hash)
- Serve from cache if user asks exact same question

---

## Testing Strategy

### Unit Tests (Jest + React Testing Library)

**Component Tests**:
- ChatMessage: Renders user/assistant messages correctly
- ChatInput: Validates input length, submits on Enter
- SourceCitation: Renders chapter/section, links to source
- ConfidenceBadge: Shows correct color/text for confidence levels
- ErrorMessage: Displays error, shows retry button if retryable

**Hook Tests**:
- useChatContext: Provides session state, sendMessage function
- useTextSelection: Captures selected text on Cmd/Ctrl+K

**API Client Tests**:
- sendChatMessage: Constructs request, handles response
- streamChatMessage: Parses SSE events, calls callbacks
- Error handling: Maps HTTP errors to user messages

**Utility Tests**:
- Session ID generation: Returns valid UUID v4
- Input validation: Catches empty, too long, invalid format

### Integration Tests (Playwright/Cypress)

**User Flows**:
1. Open chatbot, ask question, receive response
2. Select text, press Cmd+K, ask question with context
3. Ask follow-up question, verify history sent to backend
4. Clear conversation, verify new session ID generated
5. Navigate to different page, verify history persisted
6. Trigger error (stop backend), verify error message shown

**Accessibility Tests**:
- Keyboard navigation: Tab through all interactive elements
- Screen reader: Verify ARIA labels, live regions announced
- Focus management: Focus input on open, return to toggle on close

**Responsive Tests**:
- Desktop: Verify sidebar layout (400px width)
- Mobile: Verify full-screen layout (100vw x 100vh)
- Touch: Verify touch targets meet 48x48px guideline

### E2E Tests (Playwright with Real Backend)

**Complete Q&A Cycle**:
1. Start backend (docker-compose up)
2. Start frontend (npm run start)
3. Open browser to textbook page
4. Click chatbot toggle
5. Type question: "What is a ROS 2 node?"
6. Submit and wait for response
7. Assert: Response contains relevant content
8. Assert: Sources array is not empty
9. Assert: Confidence level is "high" or "medium"
10. Assert: Response latency < 5 seconds

**Streaming Test**:
1. Ask question that generates long response
2. Assert: First token arrives < 1 second
3. Assert: Tokens stream incrementally (not all at once)
4. Assert: Final message includes confidence and sources

**Error Handling Test**:
1. Stop backend
2. Ask question
3. Assert: Error message displayed
4. Assert: Retry button present
5. Restart backend
6. Click retry
7. Assert: Response arrives successfully

---

## Security Considerations

### Input Sanitization

**Client-Side**:
- Trim whitespace from user input
- Validate length (1-1000 chars)
- Send as plain text (no HTML/scripts)
- No client-side sanitization needed (backend handles)

**Backend**:
- Backend sanitizes all input (from 003-rag-agent-api spec)
- Backend escapes SQL queries (SQLAlchemy ORM)
- Backend validates session ID format (UUID v4)

### API Key Management

**Storage**:
- Environment variable: `RAG_API_KEY`
- Never commit to git (in .gitignore)
- Passed via backend config (not exposed to user)

**Usage**:
- Sent in `X-API-Key` header
- HTTPS only in production (validates baseUrl starts with https://)

### CORS Configuration

**Backend**:
- CORS middleware configured in backend (from 003-rag-agent-api)
- Allowed origins: Frontend URL (e.g., https://textbook.example.com)
- Allowed methods: GET, POST, OPTIONS
- Allowed headers: Content-Type, X-API-Key

**Frontend**:
- No CORS workarounds (no proxies, no credentials: 'include')
- Backend must allowlist frontend origin

### Session Security

**Session ID**:
- Generated client-side (crypto.randomUUID())
- Stored in sessionStorage (cleared on browser close)
- Not tied to user identity (no authentication)
- Backend does not rely on session ID for authorization

**Data Privacy**:
- No personally identifiable information (PII) sent
- Conversation history is ephemeral (sessionStorage only)
- No tracking, no analytics (MVP)

---

## Deployment and Configuration

### Environment Variables

**Development** (.env.local):
```bash
RAG_BACKEND_URL=http://localhost:8000
RAG_API_KEY=
```

**Production** (.env):
```bash
RAG_BACKEND_URL=https://api.textbook.example.com
RAG_API_KEY=prod-api-key-here
```

### Build Configuration

**Docusaurus Config** (docusaurus.config.js):
```javascript
module.exports = {
  customFields: {
    ragBackendUrl: process.env.RAG_BACKEND_URL || 'http://localhost:8000',
    ragApiKey: process.env.RAG_API_KEY || undefined,
  },
};
```

**TypeScript Config** (tsconfig.json):
```json
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "jsx": "react",
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["src"]
}
```

### Deployment Steps

**Build Frontend**:
```bash
cd docs/
npm install
npm run build
```

**Deploy to Hosting** (Vercel, Netlify, GitHub Pages):
```bash
# Set environment variables in hosting dashboard
RAG_BACKEND_URL=https://api.textbook.example.com
RAG_API_KEY=prod-api-key-here

# Deploy build output (docs/build/)
```

**Verify Deployment**:
1. Open production URL
2. Click chatbot toggle
3. Ask test question
4. Verify response arrives with citations
5. Check browser console for errors (should be none)

---

## Success Criteria Mapping

### SC-001: p95 Latency < 5 Seconds ✅
- **Measurement**: Browser Network tab, p95 of 100 requests
- **Strategy**: Use streaming to reduce perceived latency, optimize API client

### SC-002: Interface Load < 1 Second ✅
- **Measurement**: Lighthouse performance audit
- **Strategy**: Lazy load chatbot, minimize bundle size, optimize CSS

### SC-003: 95% Error Handling ✅
- **Measurement**: Test 20 error scenarios, count user-friendly messages
- **Strategy**: Map all HTTP errors to user messages, display in ErrorMessage component

### SC-004: Text Selection 5000 Characters ✅
- **Measurement**: Select 5000 char block, verify chatbot accepts
- **Strategy**: Validate selection length, show error if too long

### SC-005: 90% History Persistence ✅
- **Measurement**: Navigate 10 times, count history preserved
- **Strategy**: Save to sessionStorage on every update, load on mount

### SC-006: Streaming First Token < 1 Second ✅
- **Measurement**: Network timing, time to first content event
- **Strategy**: Use SSE streaming, backend optimized (from 003-rag-agent-api)

### SC-007: Keyboard Accessible ✅
- **Measurement**: Manual test with keyboard only (no mouse)
- **Strategy**: Implement keyboard shortcuts, focus management, ARIA

### SC-008: Mobile Compatible ✅
- **Measurement**: Test on 320px viewport, verify no horizontal scroll
- **Strategy**: Responsive CSS, full-screen layout on mobile

### SC-009: Clickable Citations ✅
- **Measurement**: Click source link, verify navigation to source
- **Strategy**: Render sources as links, construct URLs from chapter/section

### SC-010: Onboarding < 30 Minutes ✅
- **Measurement**: Time developer from "git clone" to working chatbot
- **Strategy**: Comprehensive quickstart.md, clear setup instructions

---

## Risk Analysis

### Risk 1: Backend API Latency (High Impact, Medium Probability)

**Problem**: Backend takes >5 seconds to respond, violating SC-001.

**Mitigation**:
- Use streaming to show incremental progress (first token < 1s)
- Display loading message: "Searching textbook..."
- Backend optimized with caching (from 003-rag-agent-api)
- Timeout after 30 seconds, show error message

**Fallback**: If latency remains high, add "This may take a moment" disclaimer.

### Risk 2: CORS Issues (High Impact, Low Probability)

**Problem**: Backend rejects frontend requests due to CORS misconfiguration.

**Mitigation**:
- Backend CORS already configured (from 003-rag-agent-api)
- Document required CORS settings in deployment.md
- Test CORS with curl during integration testing

**Fallback**: Backend owner must add frontend origin to allowed origins list.

### Risk 3: Mobile Keyboard Overlap (Medium Impact, Medium Probability)

**Problem**: On-screen keyboard covers input field on mobile.

**Mitigation**:
- Use `position: fixed` for input (stays above keyboard)
- Reduce panel height when keyboard appears (detect window resize)
- Test on real iOS and Android devices

**Fallback**: If issue persists, add "Scroll down to see input" hint.

### Risk 4: Streaming Fails (Low Impact, High Probability)

**Problem**: SSE streaming fails due to browser compatibility or network issues.

**Mitigation**:
- Implement fallback to synchronous POST /chat/run
- Log warning to console, no user-facing error
- Works on all browsers (Chrome, Firefox, Safari, Edge)

**Fallback**: User experiences slightly slower response (no streaming), but functionality intact.

### Risk 5: Session Storage Quota (Low Impact, Low Probability)

**Problem**: sessionStorage exceeds browser quota (5-10MB) with long conversations.

**Mitigation**:
- Limit stored messages to last 100 (trim older messages)
- Warn user if storage quota approaching
- Provide "Clear History" button to free space

**Fallback**: If quota exceeded, catch error and prompt user to clear history.

---

## Next Steps

### Immediate Actions (After /sp.plan)

1. **Review Plan**: Read through plan.md, clarify any ambiguities
2. **Run /sp.tasks**: Generate task breakdown (tasks.md) from this plan
3. **Create ADR**: Document significant architectural decisions (if any)

### Implementation Phases (From tasks.md)

**Phase 1: Core Components** (US1 - Basic Q&A, P1 MVP):
- Setup: Install dependencies, configure environment
- Types: Implement TypeScript interfaces (types.ts)
- API Client: Implement sendChatMessage() (api.ts)
- Context: Implement ChatContext and ChatProvider
- UI: Implement ChatPanel, ChatMessage, ChatInput, ChatToggle
- Integration: Wire up in Root.tsx
- Test: Manual test of basic Q&A flow

**Phase 2: Text Selection** (US2, P2):
- Implement text selection event listener (Cmd/Ctrl+K)
- Implement SelectedContext display in ChatInput
- Test: Select text, ask question with context

**Phase 3: Conversation History** (US3, P3):
- Implement sessionStorage persistence
- Implement "New Conversation" button
- Test: Multi-turn conversation, navigate pages

**Phase 4: Streaming** (US4, P4):
- Implement streamChatMessage() with SSE
- Implement incremental token rendering
- Implement fallback to synchronous
- Test: Long response streams incrementally

**Phase 5: Polish** (FR-011 to FR-015):
- Implement ConfidenceBadge, SourceCitation
- Implement ErrorMessage, LoadingIndicator
- Implement accessibility (ARIA, keyboard)
- Implement mobile responsiveness
- Test: Accessibility, mobile, error handling

**Phase 6: Testing** (All phases):
- Unit tests: Components, hooks, API client
- Integration tests: User flows, accessibility
- E2E tests: Complete Q&A cycle with real backend
- Performance tests: Latency, load time, bundle size

**Phase 7: Documentation** (Final):
- Update README with chatbot usage instructions
- Create troubleshooting guide
- Record demo video (optional)

---

## Appendix: Technical Decision Log

All technical decisions documented in `research.md`:

1. **Framework Integration**: Docusaurus React Components (vs iframe/browser extension)
2. **State Management**: React Context + sessionStorage (vs Redux/Zustand)
3. **API Client**: Native fetch with custom hooks (vs axios/SWR)
4. **Markdown Rendering**: react-markdown + remark-gfm (vs marked/markdown-it)
5. **Text Selection**: window.getSelection() + Cmd/Ctrl+K (vs right-click menu)
6. **Streaming**: EventSource API + @microsoft/fetch-event-source (vs WebSockets)
7. **Configuration**: Environment variables via Docusaurus customFields (vs runtime config API)
8. **CORS**: Backend-configured (vs frontend proxy)
9. **Accessibility**: ARIA labels + keyboard navigation (WCAG 2.1 AA)
10. **Mobile**: Responsive design (full screen <768px, sidebar >768px)

---

**Plan Status**: Complete and ready for `/sp.tasks` command.

**Estimated Implementation Time**: 40-60 hours (1-2 weeks for 1 developer).

**Dependencies**: Backend API (003-rag-agent-api) must be operational before E2E testing.
