---
title: "Chapter 1: Physics Simulation with Gazebo"
description: "Learn physics-accurate simulation of humanoid robots using Gazebo Fortress"
sidebar_position: 1
---

import CodeBlock from '@theme/CodeBlock';

# Chapter 1: Physics Simulation with Gazebo

## 1.1 Introduction

Digital twins are virtual replicas of physical systems that enable testing, validation, and optimization without expensive hardware prototypes. For humanoid robots, physics-accurate simulation is critical—controllers designed in simulation must transfer to real hardware without catastrophic failures.

**Gazebo** is an open-source robotics simulator that provides physics-accurate simulation of robots and environments. Unlike game engines optimized for visual realism, Gazebo prioritizes physical accuracy, making it the industry standard for robotics research and development.

### Learning Objectives

By the end of this chapter, you will be able to:

1. Set up a reproducible Gazebo Fortress environment using Docker
2. Create simulation worlds with configurable physics parameters
3. Import and configure humanoid robot models with proper inertial properties
4. Diagnose and fix common physics simulation issues (jitter, explosions, instability)
5. Validate simulation accuracy against expected physical behavior

### Why Physics Simulation Matters

Consider a humanoid robot designed to walk on uneven terrain. Testing on real hardware is:
- **Expensive**: Each fall can damage motors, sensors, and structural components ($500-$5000 per incident)
- **Time-consuming**: Iterating on control algorithms requires robot setup, testing, data collection, and repairs
- **Dangerous**: High-torque motors can cause injuries during unexpected behaviors

Physics simulation enables rapid iteration at zero marginal cost. You can test thousands of scenarios—falls, collisions, edge cases—without risk. However, simulation is only useful if it accurately predicts real-world behavior. This requires understanding:
- **Collision dynamics**: How objects interact on contact (friction, restitution, contact forces)
- **Rigid body dynamics**: How forces and torques cause motion (Newton's laws, Euler integration)
- **Joint constraints**: How actuators apply torques and enforce position/velocity limits

Gazebo models these phenomena using physics engines like ODE (Open Dynamics Engine), allowing you to validate robot designs before fabrication.

---

## 1.2 Gazebo Setup with Docker

Docker provides a containerized environment that eliminates "works on my machine" problems. We'll use the official ROS 2 Humble + Gazebo Fortress image.

### System Requirements

- **OS**: Linux (native), Windows 10/11 (WSL2), or macOS (with XQuartz)
- **RAM**: 8 GB minimum, 16 GB recommended
- **GPU**: Not required for basic simulations (CPU-based physics), but improves GUI performance
- **Disk Space**: 5 GB for Docker image and workspaces

### Installation Steps

#### 1. Install Docker

**Linux (Ubuntu/Debian)**:
```bash
# Install Docker Engine
sudo apt-get update
sudo apt-get install -y docker.io docker-compose
sudo usermod -aG docker $USER  # Add user to docker group
newgrp docker  # Activate group changes
```

**Windows**:
1. Install [Docker Desktop for Windows](https://www.docker.com/products/docker-desktop/)
2. Enable WSL2 backend in Docker Desktop settings
3. Install Ubuntu from Microsoft Store
4. Restart computer

**macOS**:
1. Install [Docker Desktop for Mac](https://www.docker.com/products/docker-desktop/)
2. Install [XQuartz](https://www.xquartz.org/) for X11 forwarding
3. In XQuartz preferences: Enable "Allow connections from network clients"

#### 2. Clone Docker Configuration

Our Gazebo Docker setup is located in `docker/gazebo-fortress/`:

```bash
cd ~/physical-ai-humanoid-book
ls docker/gazebo-fortress/
# Dockerfile  docker-compose.yml  run_gazebo.sh  README.md
```

#### 3. Build Docker Image

```bash
cd docker/gazebo-fortress
docker-compose build
```

This pulls the `osrf/ros:humble-desktop-full` base image and installs:
- Gazebo Fortress (version 6.x)
- ROS 2 Humble packages (`gazebo_ros_pkgs`, sensor plugins)
- Python tools: `open3d`, `matplotlib`, `pandas` for data processing

**Expected output**:
```
Successfully built abc123def456
Successfully tagged gazebo-fortress:latest
```

**Build time**: 5-15 minutes depending on internet speed.

#### 4. Launch Gazebo

**Linux**:
```bash
./run_gazebo.sh
```

**WSL2 (Windows)**:
Install an X server like [VcXsrv](https://sourceforge.net/projects/vcxsrv/):
1. Launch VcXsrv with "Disable access control" enabled
2. Run `./run_gazebo.sh` in WSL2 terminal

**macOS**:
```bash
# Start XQuartz first
open -a XQuartz
xhost +localhost  # Allow Docker to connect to X server

# Then launch Gazebo
./run_gazebo.sh
```

#### 5. Verify Installation

You should see the Gazebo GUI with an empty world:

![Empty Gazebo world in Docker](./assets/screenshots/01-empty-gazebo.png)

**Troubleshooting**:
- **Error: "cannot connect to X server"**: Ensure `DISPLAY` environment variable is set (`echo $DISPLAY`)
- **Error: "docker: permission denied"**: Add user to docker group or use `sudo`
- **Slow GUI performance**: Increase Docker resource limits (Docker Desktop → Settings → Resources)

---

## 1.3 Creating Your First World

Gazebo worlds are defined in SDF (Simulation Description Format), an XML-based language for describing simulation environments.

### Basic World Structure

Create `simple_world.sdf` with a ground plane and lighting:

<CodeBlock language="xml" title="simple_world.sdf" showLineNumbers>
{`<?xml version="1.0"?>
<sdf version="1.8">
  <world name="simple_world">
    <!-- Physics configuration -->
    <physics type="ode">
      <gravity>0 0 -9.81</gravity>
      <max_step_size>0.001</max_step_size>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Lighting -->
    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>1.0 1.0 1.0 1.0</diffuse>
      <specular>0.5 0.5 0.5 1.0</specular>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <!-- Ground plane -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>1.0</mu>
                <mu2>1.0</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>`}
</CodeBlock>

### Key Physics Parameters

| Parameter | Value | Purpose |
|-----------|-------|---------|
| `gravity` | `0 0 -9.81` | Earth gravity (m/s²) in Z-axis (down) |
| `max_step_size` | `0.001` | Physics timestep (1ms for stable humanoid simulation) |
| `real_time_update_rate` | `1000` | Target physics updates per second (1000 Hz) |
| `mu` / `mu2` | `1.0` | Friction coefficients (0=frictionless, 1=rubber on concrete) |

**Physics timestep trade-offs**:
- **Smaller timestep** (0.0001s): More accurate, slower simulation, prevents tunneling through thin objects
- **Larger timestep** (0.01s): Faster simulation, less accurate, can cause jitter or explosions

For humanoid robots with many joints, `0.001s` (1ms) is a good balance.

### Testing Physics

Let's add a sphere to test gravity:

```bash
# In Gazebo GUI: Insert → Sphere
# Or add to SDF:
```

```xml
<model name="test_sphere">
  <pose>0 0 2 0 0 0</pose>  <!-- Start at 2m height -->
  <link name="link">
    <inertial>
      <mass>1.0</mass>
      <inertia>
        <ixx>0.4</ixx><iyy>0.4</iyy><izz>0.4</izz>
      </inertia>
    </inertial>
    <collision name="collision">
      <geometry>
        <sphere><radius>0.1</radius></sphere>
      </geometry>
    </collision>
    <visual name="visual">
      <geometry>
        <sphere><radius>0.1</radius></sphere>
      </geometry>
    </visual>
  </link>
</model>
```

Press **Play** (bottom left). The sphere should fall and bounce on the ground.

**Validation**:
- Free fall time for 2m: `t = sqrt(2h/g) = sqrt(2*2/9.81) ≈ 0.64s`
- Gazebo should match this ±5%

![Sphere falling under gravity](./assets/screenshots/01-gravity-test.png)

### Launch Script

For convenience, create `launch_gazebo.sh`:

```bash
#!/bin/bash
gazebo --verbose simple_world.sdf
```

Make it executable:
```bash
chmod +x launch_gazebo.sh
./launch_gazebo.sh
```

---

## 1.4 Importing Humanoid Models

Humanoid robots require careful inertial configuration to prevent simulation instability.

### URDF to SDF Conversion

Module 1 covered URDF creation. Gazebo natively supports URDF, but SDF provides more features. To convert:

```bash
# Using gz sdf command (inside Docker)
gz sdf -p humanoid.urdf > humanoid.sdf
```

### Critical Inertial Properties

**Why inertia matters**: Incorrect inertia causes:
- **Jitter**: Robot vibrates uncontrollably
- **Explosions**: Joints fly apart due to excessive constraint forces
- **Collapse**: Robot immediately falls or sinks into ground

Each link MUST have:
1. **Mass** (kg): Total mass of the component
2. **Center of Mass** (m): Where mass is concentrated relative to link origin
3. **Inertia Tensor** (kg⋅m²): Rotational resistance around X, Y, Z axes

### Example: Humanoid Torso

<CodeBlock language="xml" title="humanoid_physics.urdf (excerpt)" showLineNumbers>
{`<link name="torso">
  <inertial>
    <origin xyz="0 0 0.2" rpy="0 0 0"/>  <!-- CoM 20cm above link origin -->
    <mass value="5.0"/>  <!-- 5 kg torso -->
    <inertia
      ixx="0.1" iyy="0.1" izz="0.05"  <!-- Moment of inertia -->
      ixy="0" ixz="0" iyz="0"/>  <!-- Off-diagonal terms (usually 0 for symmetric parts) -->
  </inertial>
  <collision name="collision">
    <geometry>
      <box size="0.3 0.2 0.5"/>
    </geometry>
  </collision>
  <visual name="visual">
    <geometry>
      <box size="0.3 0.2 0.5"/>
    </geometry>
    <material name="gray">
      <color rgba="0.5 0.5 0.5 1.0"/>
    </material>
  </visual>
</link>`}
</CodeBlock>

**How to calculate inertia**:
For simple shapes, use formulas:
- **Box**: `Ixx = (1/12) * m * (h² + d²)`, `Iyy = (1/12) * m * (w² + h²)`, `Izz = (1/12) * m * (w² + d²)`
- **Cylinder**: `Ixx = Iyy = (1/12) * m * (3r² + h²)`, `Izz = (1/2) * m * r²`
- **Sphere**: `Ixx = Iyy = Izz = (2/5) * m * r²`

For complex meshes, use CAD software (SolidWorks, Fusion 360) or `meshlab`/`MeshLab` to compute.

### Common Mistakes

| Issue | Symptom | Fix |
|-------|---------|-----|
| **Zero inertia** | Robot collapses instantly | Set realistic values (use formulas above) |
| **Mass too low** | Robot floats or drifts | Increase mass to match real-world component (kg, not grams) |
| **CoM far from geometry** | Robot tilts unexpectedly | Move CoM closer to visual geometry center |
| **Missing collision geometry** | Robot falls through ground | Add `<collision>` element matching visual shape |

### Testing Your Robot

1. Load URDF in Gazebo:
```bash
gazebo humanoid_physics.urdf
```

2. Press **Play**. Robot should:
   - Stand upright (if balanced) or fall predictably (if unbalanced)
   - Not vibrate, explode, or sink into ground
   - Respond to forces (try GUI "Apply Force" tool)

**Correct configuration**:
![Humanoid standing with correct inertia](./assets/screenshots/01-humanoid-standing.png)

**Incorrect configuration** (zero inertia):
![Humanoid collapsed with incorrect inertia](./assets/screenshots/01-humanoid-collapsed.png)

---

## 1.5 Physics Troubleshooting

Even with correct inertial properties, simulation can be unstable. Here's how to diagnose and fix common issues.

### Problem 1: Jitter (High-Frequency Vibration)

**Symptoms**: Robot or objects vibrate rapidly, especially in contact with ground or other objects.

**Causes**:
- Physics timestep too large relative to stiffness
- Solver iterations too low
- Contact forces oscillating due to poor constraint solving

**Fix**: Increase solver iterations and adjust constraint parameters.

<CodeBlock language="xml" title="physics_tuning.sdf" showLineNumbers>
{`<physics type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_update_rate>1000</real_time_update_rate>

  <ode>
    <solver>
      <type>quick</type>
      <iters>50</iters>  <!-- Increased from default 20 -->
      <sor>1.3</sor>  <!-- Successive over-relaxation parameter -->
    </solver>
    <constraints>
      <cfm>0.0</cfm>  <!-- Constraint Force Mixing (0 = rigid constraints) -->
      <erp>0.2</erp>  <!-- Error Reduction Parameter (lower = less bouncy) -->
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>  <!-- Penetration tolerance -->
    </constraints>
  </ode>
</physics>`}
</CodeBlock>

**Before/After**:
![Jitter fix comparison](./assets/screenshots/01-jitter-fix.png)

### Problem 2: Robot Explodes (Joints Fly Apart)

**Symptoms**: Links separate violently, robot "explodes" into pieces.

**Causes**:
- Joint limits not enforced
- Excessive joint forces
- Inertia mismatch between parent and child links

**Fix**:
1. Add joint limits and damping:
```xml
<joint name="hip_joint" type="revolute">
  <parent>torso</parent>
  <child>upper_leg</child>
  <axis>
    <xyz>0 1 0</xyz>
    <limit>
      <lower>-1.57</lower>  <!-- -90 degrees -->
      <upper>1.57</upper>   <!-- +90 degrees -->
      <effort>100</effort>  <!-- Max torque (N⋅m) -->
      <velocity>2.0</velocity>  <!-- Max angular velocity (rad/s) -->
    </limit>
    <dynamics>
      <damping>0.1</damping>  <!-- Joint damping coefficient -->
      <friction>0.0</friction>
    </dynamics>
  </axis>
</joint>
```

2. Ensure child link mass is reasonable relative to parent (avoid 100x differences).

### Problem 3: Slow Simulation

**Symptoms**: Simulation runs slower than real-time (Real Time Factor < 1.0).

**Causes**:
- Too many collision checks (complex meshes)
- Physics timestep too small
- Solver iterations too high

**Fixes**:
1. **Simplify collision geometry**: Use boxes/cylinders instead of meshes
```xml
<collision name="collision">
  <geometry>
    <box size="0.1 0.1 0.2"/>  <!-- Simple box, not detailed mesh -->
  </geometry>
</collision>
```

2. **Reduce solver iterations** (if jitter is acceptable):
```xml
<solver>
  <iters>20</iters>  <!-- Lower from 50 -->
</solver>
```

3. **Increase timestep** (test carefully):
```xml
<max_step_size>0.002</max_step_size>  <!-- 2ms instead of 1ms -->
```

### Problem 4: Robot Sinks Into Ground

**Symptoms**: Robot gradually penetrates ground plane.

**Causes**:
- Contact surface layer too large
- ERP (Error Reduction Parameter) too high
- Insufficient contact normal force

**Fix**:
```xml
<constraints>
  <contact_surface_layer>0.0001</contact_surface_layer>  <!-- Reduce penetration tolerance -->
  <erp>0.2</erp>  <!-- Lower ERP reduces "springiness" -->
</constraints>
```

### Collision Testing

Test robot collision behavior with obstacles:

![Robot collision with obstacle](./assets/screenshots/01-collision-test.png)

Add a box obstacle:
```xml
<model name="obstacle">
  <pose>1 0 0.5 0 0 0</pose>
  <link name="link">
    <collision name="collision">
      <geometry>
        <box size="0.5 0.5 1.0"/>
      </geometry>
    </collision>
    <visual name="visual">
      <geometry>
        <box size="0.5 0.5 1.0"/>
      </geometry>
    </visual>
  </link>
</model>
```

Apply force to robot (GUI → "Apply Force/Torque" tool). Robot should:
- Collide and stop (not pass through)
- Bounce or slide based on friction/restitution
- Maintain structural integrity (joints don't break)

---

## 1.6 Exercises

### Exercise 1: Gravity Validation

**Objective**: Verify simulation accuracy by measuring free fall time.

**Tasks**:
1. Create a world with a sphere at height `h = 5m`
2. Record time until sphere hits ground (use Gazebo topics: `/gazebo/default/model/test_sphere/pose`)
3. Compare to theoretical: `t = sqrt(2h/g)`
4. Acceptable error: ±5%

**Deliverable**: Screenshot showing sphere trajectory and calculated vs. expected fall time.

### Exercise 2: Friction Experiment

**Objective**: Observe how friction affects sliding behavior.

**Tasks**:
1. Create a tilted ramp (10° angle)
2. Place a box on ramp with:
   - Low friction: `mu = 0.1`
   - High friction: `mu = 2.0`
3. Predict: Will box slide down?
4. Test in simulation

**Theory**: Box slides if `tan(θ) > μ` (friction coefficient).
- `tan(10°) ≈ 0.176`
- Low friction (0.1): Should slide
- High friction (2.0): Should stay

**Deliverable**: Video or screenshots showing both cases, with explanation.

### Exercise 3: Humanoid Balance

**Objective**: Configure a humanoid to stand without falling.

**Tasks**:
1. Import your Module 1 humanoid URDF
2. Adjust inertial properties until robot stands upright for 10+ seconds
3. Document:
   - Final mass distribution (kg per link)
   - Center of mass locations
   - Any physics tuning parameters used

**Hint**: Lower center of mass improves stability. Move heavy components (battery, motors) to torso base.

**Deliverable**: Screenshot of standing robot, URDF file with inertial values.

---

## Summary

In this chapter, you learned:

- ✅ How to set up reproducible Gazebo environments using Docker
- ✅ Physics simulation fundamentals: gravity, friction, dynamics
- ✅ Creating SDF worlds with configurable physics parameters
- ✅ Importing humanoid URDF models with proper inertial properties
- ✅ Diagnosing and fixing simulation issues (jitter, explosions, slow performance)
- ✅ Validating simulation accuracy against physical theory

**Key Takeaways**:
1. **Physics accuracy is non-negotiable**: Controllers tested in poor simulations will fail on real hardware
2. **Inertial properties matter**: Mass, center of mass, and inertia tensor must be realistic
3. **Tuning is iterative**: Start with default parameters, adjust based on observed behavior
4. **Validate continuously**: Compare simulation to theory (gravity, free fall, friction)

**Next Chapter**: We'll shift from physics accuracy to high-fidelity visualization using Unity, enabling realistic rendering for vision algorithms and stakeholder demonstrations.

---

## Additional Resources

- [Gazebo Fortress Documentation](https://gazebosim.org/docs/fortress/)
- [SDF Format Specification](http://sdformat.org/spec)
- [ODE Physics Engine Manual](https://ode.org/wiki/index.php/Manual)
- [ROS 2 + Gazebo Integration Guide](https://github.com/ros-simulation/gazebo_ros_pkgs)
- [Inertia Calculations for Common Shapes](https://en.wikipedia.org/wiki/List_of_moments_of_inertia)

**Estimated Time**: 4-6 hours to complete chapter and exercises
